% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/semipaddgt2pop_gt.R
\name{semipaddgt2pop_cv_adapt}
\alias{semipaddgt2pop_cv_adapt}
\title{Compute semiparametric regression model on group testing data with 2 data sets while penalizing dissimilarity}
\usage{
semipaddgt2pop_cv_adapt(Y1, Z1, Se1, Sp1, X1, nonparm1, Y2, Z2, Se2, Sp2, X2,
  nonparm2, w1, w2, w, nCom, d1, d2, xi, n.lambda = 5, n.eta = 5,
  lambda.min.ratio = 0.01, n.folds = 5, lambda.beta = 1, lambda.f = 1,
  eta.beta = 1, eta.f = 1, E.approx = FALSE, tol = 0.001,
  max.iter = 1000, report.prog = FALSE)
}
\arguments{
\item{Y1}{Group testing output for data set 1 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Z1}{Group testing output for data set 1 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Se1}{A vector of testing sensitivities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{Sp1}{A vector of testing specificities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{X1}{the matrix with the observed covariate values for data set 1 (including a column of ones for the intercept)}

\item{nonparm1}{a vector indicating for which covariates a nonparametric function is to be estimated for data set 1}

\item{Y2}{Group testing output for data set 2 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Z2}{Group testing output for data set 2 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Se2}{A vector of testing sensitivities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{Sp2}{A vector of testing specificities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{X2}{the matrix with the observed covariate values for data set 2 (including a column of ones for the intercept)}

\item{nonparm2}{a vector indicating for which covariates a nonparametric function is to be estimated for data set 2}

\item{w1}{covariate-specific weights for different penalization among covariates in data set 1}

\item{w2}{covariate-specific weights for different penalization among covariates in data set 2}

\item{w}{covariate-specific weights for different penalization toward similarity for different covariates}

\item{nCom}{the number of covariates to be treated as common between the two data sets: these must be arranged in the first \code{nCom} columns of the matrices \code{X1} and \code{X2} after the column of ones corresponding to the intercept.}

\item{d1}{vector giving the dimensions the B-spline bases to be used when fitting the nonparametric effects. If a scalar is given, this dimension is used for all nonparametric effects.}

\item{d2}{vector giving the dimensions the B-spline bases to be used when fitting the nonparametric effects. If a scalar is given, this dimension is used for all nonparametric effects.}

\item{xi}{a tuning parameter governing the smoothness of the nonparametric estimates}

\item{n.lambda}{the number of lambda values with which to make the grid}

\item{n.eta}{the number of eta values with which to make the grid}

\item{lambda.min.ratio}{ratio of the smallest lambda value to the smallest value of lambda which admits no variables to the model}

\item{lambda.beta}{the level of sparsity penalization for the parametric effects (relative to nonparametric effects)}

\item{lambda.f}{the level of sparsity penalization for the nonparametric effects (relative to the parametric effects)}

\item{eta.beta}{the level of penalization towards model similarity for parametric effects indicated to be common (relative to nonparametric effects)}

\item{eta.f}{the level of penalization towards model similarity for nonparametric effects indicated to be common (relative to the parametric effects)}

\item{E.approx}{a logical indicating whether the conditional expectations in the E-step should be computed approximately or exactly.}

\item{tol}{a convergence criterion}

\item{max.iter}{the maximum allowed number of iterations (EM steps)}

\item{report.prog}{a logical. If \code{TRUE} then the number of inner loops required to complete the M step of the EM algorithm are returned after each EM step.}
}
\value{
Returns the estimator of the semiparametric additive model with group testing data
}
\description{
Compute semiparametric regression model on group testing data with 2 data sets while penalizing dissimilarity
}
\examples{
semipaddgt2pop_data <- get_semipaddgt2pop_data(n1 = 500, n2 = 604)

semipaddgt2pop_cv.out <- semipaddgt2pop_cv(Y1 = semipaddgt2pop_data$Y1,
                                           Z1 = semipaddgt2pop_data$Z1,
                                           Se1 = semipaddgt2pop_data$Se1,
                                           Sp1 = semipaddgt2pop_data$Sp1,
                                           X1 = semipaddgt2pop_data$X1,
                                           nonparm1 = semipaddgt2pop_data$nonparm1,
                                           Y2 = semipaddgt2pop_data$Y2,
                                           Z2 = semipaddgt2pop_data$Z2,
                                           Se2 = semipaddgt2pop_data$Se2,
                                           Sp2 = semipaddgt2pop_data$Sp2,
                                           X2 = semipaddgt2pop_data$X2,
                                           nonparm2 = semipaddgt2pop_data$nonparm2,
                                           w1 = 1,
                                           w2 = 1,
                                           w = 1,
                                           nCom = 4,
                                           d1 = semipaddgt2pop_data$nonparm1 * 15,
                                           d2 = semipaddgt2pop_data$nonparm2 * 10,
                                           xi = 1,
                                           n.lambda = 3,
                                           n.eta = 3,
                                           lambda.min.ratio =.001,
                                           lambda.beta = 1,
                                           lambda.f = 1,
                                           eta.beta = 1,
                                           eta.f = 1,
                                           tol = 1e-2,
                                           max.iter = 500,
                                           report.prog = TRUE)

plot_semipaddgt2pop_cv(semipaddgt2pop_cv.out,
                       true.functions = list(f1 = semipaddgt2pop_data$f1,
                                             f2 = semipaddgt2pop_data$f2,
                                             X1 = semipaddgt2pop_data$X1,
                                             X2 = semipaddgt2pop_data$X2)
)
}
