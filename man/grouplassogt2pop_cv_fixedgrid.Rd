% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/semipaddgt2pop_gt.R
\name{grouplassogt2pop_cv_fixedgrid}
\alias{grouplassogt2pop_cv_fixedgrid}
\title{Choose tuning parameters by crossvalidation for grouplassogt2pop when given a fixed grid of lambda and eta values}
\usage{
grouplassogt2pop_cv_fixedgrid(Y1, Z1, Se1, Sp1, X1, groups1, Y2, Z2, Se2, Sp2,
  X2, groups2, lambda.seq, eta.seq, n.folds, b1.init.arr, b2.init.arr, w1, w2,
  w, AA1, AA2, Com, E.approx = FALSE, tol = 0.001, max.iter = 500)
}
\arguments{
\item{Y1}{Group testing output for data set 1 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Z1}{Group testing output for data set 1 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Se1}{A vector of testing sensitivities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{Sp1}{A vector of testing specificities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{X1}{the matrix with the observed covariate values for data set 1 (including a column of ones for the intercept)}

\item{groups1}{a vector indicating to which group each covariate of data set 2 belongs}

\item{Y2}{Group testing output for data set 2 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Z2}{Group testing output for data set 2 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Se2}{A vector of testing sensitivities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{Sp2}{A vector of testing specificities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{X2}{the matrix with the observed covariate values for data set 2 (including a column of ones for the intercept)}

\item{groups2}{a vector indicating to which group each covariate of data set 2 belongs}

\item{lambda.seq}{the sequence of lambda values}

\item{eta.seq}{the sequence of eta values}

\item{n.folds}{the number of crossvalidation folds}

\item{b1.init.arr}{array of initial values for beta1}

\item{b2.init.arr}{array of initial values for beta2}

\item{w1}{group-specific weights for different penalization across groups in data set 1}

\item{w2}{group-specific weights for different penalization across groups in data set 2}

\item{w}{group-specific weights for different penalization toward similarity for different groups}

\item{AA1}{a list of the matrices A1j}

\item{Com}{the indices of the covariate groups which are common in the two datasets}

\item{E.approx}{a logical indicating whether the conditional expectations in the E-step should be computed approximately or exactly.}

\item{tol}{a convergence criterion}

\item{max.iter}{the maximum allowed number of iterations (EM steps)}

\item{AA1}{a list of the matrices A2j}
}
\value{
a list containing the fits over a grid of lambda and eta values as well as the vector of lambda values and the vector of eta values
}
\description{
Choose tuning parameters by crossvalidation for grouplassogt2pop when given a fixed grid of lambda and eta values
}
\examples{
grouplassogt2pop_data <- get_grouplassogt2pop_data(n1=400,n2=600)

grouplassogt2pop_grid.out <- grouplassogt2pop_grid(Y1 = grouplassogt2pop_data$Y1,
                                                   Z1 = grouplassogt2pop_data$Z1,
                                                   Se1 = grouplassogt2pop_data$Se1,
                                                   Sp1 = grouplassogt2pop_data$Sp1,
                                                   X1 = grouplassogt2pop_data$X1,
                                                   groups1 = grouplassogt2pop_data$groups1,
                                                   Y2 = grouplassogt2pop_data$Y2,
                                                   Z2 = grouplassogt2pop_data$Z2,
                                                   Se2 = grouplassogt2pop_data$Se2,
                                                   Sp2 = grouplassogt2pop_data$Sp2,
                                                   X2 = grouplassogt2pop_data$X2,
                                                   groups2 = grouplassogt2pop_data$groups2,
                                                   n.lambda = 5,
                                                   n.eta = 5,
                                                   lambda.min.ratio = 0.01,
                                                   w1 = grouplassogt2pop_data$w1,
                                                   w2 = grouplassogt2pop_data$w2,
                                                   w = grouplassogt2pop_data$w,
                                                   AA1 = grouplassogt2pop_data$AA1,
                                                   AA2 = grouplassogt2pop_data$AA2,
                                                   Com = grouplassogt2pop_data$Com,
                                                   tol = 1e-2,
                                                   max.iter = 500,
                                                   report.prog = TRUE)

grouplassogt2pop_cv_fixedgrid.out <- grouplassogt2pop_cv_fixedgrid(Y1 = grouplassogt2pop_data$Y1,
                                                                   Z1 = grouplassogt2pop_data$Z1,
                                                                   Se1 = grouplassogt2pop_data$Se1,
                                                                   Sp1 = grouplassogt2pop_data$Sp1,
                                                                   X1 = grouplassogt2pop_data$X1,
                                                                   groups1 = grouplassogt2pop_data$groups1,
                                                                   Y2 = grouplassogt2pop_data$Y2,
                                                                   Z2 = grouplassogt2pop_data$Z2,
                                                                   Se2 = grouplassogt2pop_data$Se2,
                                                                   Sp2 = grouplassogt2pop_data$Sp2,
                                                                   X2 = grouplassogt2pop_data$X2,
                                                                   groups2 = grouplassogt2pop_data$groups2,
                                                                   lambda.seq = grouplassogt2pop_grid.out$lambda.seq,
                                                                   eta.seq = grouplassogt2pop_grid.out$eta.seq,
                                                                   n.folds = 5,
                                                                   b1.init.arr = grouplassogt2pop_grid.out$b1.arr,
                                                                   b2.init.arr = grouplassogt2pop_grid.out$b2.arr,
                                                                   w1 = grouplassogt2pop_data$w1,
                                                                   w2 = grouplassogt2pop_data$w2,
                                                                   w = grouplassogt2pop_data$w,
                                                                   AA1 = grouplassogt2pop_data$AA1,
                                                                   AA2 = grouplassogt2pop_data$AA2,
                                                                   Com = grouplassogt2pop_data$Com,
                                                                   tol = 1e-2,
                                                                   max.iter = 500)
}
