% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/semipaddgt2pop_1pop.R
\name{semipaddgt1pop_logreg}
\alias{semipaddgt1pop_logreg}
\title{Compute semiparametric binary-response regression model with 1 data set}
\usage{
semipaddgt1pop_logreg(Y1, Z1, Se1, Sp1, XX1, nonparm1, w1, d, xi, lambda.beta,
  lambda.f, tol = 0.001, max.iter = 500, report.prog = FALSE)
}
\arguments{
\item{Y1}{Group testing output for data set 1 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Z1}{Group testing output for data set 1 in the format as output by one of the functions \code{individual.assay.gen}, \code{masterpool.assay.gen}, \code{dorfman.assay.gen}, or \code{array.assay.gen}.}

\item{Se1}{A vector of testing sensitivities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{Sp1}{A vector of testing specificities, where the first element is the
testing specificity for pools and the second entry is the
test specificity for individual testing, if applicable.}

\item{XX1}{the matrix with the observed covariate values for data set 1 (including a column of ones for the intercept)}

\item{nonparm1}{a vector indicating for which covariates a nonparametric function is to be estimated for data set 1}

\item{w1}{covariate-specific weights for different penalization among covariates in data set 1}

\item{d}{the dimension of the B-spline basis to be used when fitting the nonparametric effects}

\item{xi}{a tuning parameter governing the smoothness of the nonparametric estimates}

\item{lambda.beta}{the level of sparsity penalization for the parametric effects}

\item{lambda.f}{the level of sparsity penalization for the nonparametric effects}

\item{tol}{a convergence criterion}

\item{max.iter}{the maximum allowed number of iterations (EM steps)}

\item{report.prog}{a logical. If \code{TRUE} then the number of inner loops required to complete the M step of the EM algorithm are returned after each EM step.}
}
\value{
Returns the estimator of the semiparametric additive model with group testing data
}
\description{
Compute semiparametric binary-response regression model with 1 data set
}
\examples{
# generate data set
n1 <- 200
p1 <- 6
q1 <- 4
zeta1 <- 3/20
zeta2 <- 10/20
W1 <- cbind(corrBern(n1,probs=c(1:p1)/(2*p1),Rho = zeta1^abs(outer(1:p1,1:p1,"-"))))
X1 <- (corrUnif(n1,Rho = zeta2^abs(outer(1:q1,1:q1,"-")))-.5)*5

XX1 <- cbind(1,W1[,c(1,2)],X1[,c(1,2)],W1[,-c(1,2)],X1[,-c(1,2)])
nonparm1 <- c(0,rep(0,2),rep(1,2),rep(0,p1 - 2),rep(1,q1 - 2))
pp1 <- ncol(XX1)

# set up the true functions
f1 <- vector("list",pp1)
f1[[1]] <- function(x){0} # intercept
f1[[2]] <- function(x){x*2}
f1[[3]] <- function(x){x*0}
f1[[4]] <- function(x){-sin(x*2) }
f1[[5]] <- function(x){x}
f1[[6]] <- function(x){x*2}
f1[[7]] <- function(x){x*0}
f1[[8]] <- function(x){0*x}
f1[[9]] <- function(x){0*x}
f1[[10]] <- function(x){0*x}
f1[[11]] <- function(x){exp(-x)-2/5*sinh(5/2)}

f1.design <- matrix(0,n1,pp1)
for(j in 1:pp1){
  if(nonparm1[j]==1){
    f1.design[,j] <- f1[[j]](XX1[,j]) - mean(f1[[j]](XX1[,j]))
  } else {
    f1.design[,j] <- f1[[j]](XX1[,j])
  }
}

Y1.true <- rbinom(n1,1,logit(apply(f1.design,1,sum)))

Se1 <- c(.98,.96)
Sp1 <- c(.97,.99)
assay1.out <- dorfman.assay.gen(Y1.true,Se1,Sp1,cj=4)
Z1 <- assay1.out$Z
Y1 <- assay1.out$Y

semipaddgt1pop.out <- semipaddgt1pop_logreg(Y1,
                                     Z1,
                                     Se1,
                                     Sp1,
                                     XX1,
                                     nonparm1,
                                     w1=1,
                                     d=20,
                                     xi=.5,
                                     lambda.beta=2,
                                     lambda.f=1,
                                     tol=1e-3,
                                     max.iter = 50,
                                     report.prog = TRUE)

f1.hat.design <- semipaddgt1pop.out$f1.hat.design
f1.hat <- semipaddgt1pop.out$f1.hat
knots.list1 <- semipaddgt1pop.out$knots.list1
nonparm1 <- semipaddgt1pop.out$nonparm1

# number of iterations
semipaddgt1pop.out$inner.iter

# plot results
par(mfrow=c(3,4),mar=c(0,0,0,0))
for( j in 2:pp1){

  plot(NA,ylim = range(f1.hat.design),xlim=range(XX1[,j]),xaxt="n",yaxt="n")
  if(nonparm1[j]==1) abline(v=knots.list1[[j]],col=rgb(0,0,0,.15))

  plot(f1.hat[[j]],min(XX1[,j]),max(XX1[,j]),add=TRUE)
  x1.seq <- seq(min(XX1[,j]),max(XX1[,j]),length=300)
  f1.cent.seq <- f1[[j]](x1.seq) - mean(f1[[j]](XX1[,j]))
  lines(f1.cent.seq ~ x1.seq,lty=2)
}
}
