% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/semipaddgt2pop_logreg.R
\name{grouplasso2pop_logreg_cv}
\alias{grouplasso2pop_logreg_cv}
\title{Choose tuning parameters by crossvalidation for grouplasso2pop logreg.}
\usage{
grouplasso2pop_logreg_cv(Y1, X1, groups1, Y2, X2, groups2, n.lambda, n.eta,
  lambda.min.ratio, n.folds, w1, w2, w, AA1, AA2, Com, tol = 1e-04,
  max.iter = 500, report.prog = TRUE)
}
\arguments{
\item{Y1}{the binary response vector of data set 1}

\item{X1}{matrix containing the design matrices for data set 1}

\item{groups1}{a vector indicating to which group each covariate of data set 1 belongs}

\item{Y2}{the binary response vector of data set 2}

\item{X2}{matrix containing the design matrices for data set 2}

\item{groups2}{a vector indicating to which group each covariate of data set 2 belongs}

\item{n.lambda}{the number of lambda values desired}

\item{n.eta}{the number of eta values desired}

\item{lambda.min.ratio}{ratio of the smallest lambda value to the smallest value of lambda which admits no variables to the model}

\item{n.folds}{the number of crossvalidation folds}

\item{w1}{group-specific weights for different penalization across groups in data set 1}

\item{w2}{group-specific weights for different penalization across groups in data set 2}

\item{w}{group-specific weights for different penalization toward similarity for different groups}

\item{AA1}{a list of the matrices A1j}

\item{Com}{the indices of the covariate groups which are common in the two datasets}

\item{AA1}{a list of the matrices A2j}
}
\value{
a list containing the fits over a grid of lambda and eta values as well as the vector of lambda values and the vector of eta values
}
\description{
Choose tuning parameters by crossvalidation for grouplasso2pop logreg.
}
\examples{
# generate data
n1 <- 403
d1 <- c(1,1,3,4)
q1 <- length(d1)
X1 <- matrix(rnorm(n1*sum(d1)),n1,sum(d1))
groups1 <- numeric() ; for(j in 1:q1){ groups1 <- c(groups1,rep(j,d1[j])) }

n2 <- 601
d2 <- c(1,1,4,3,3,2)
q2 <- length(d2)
X2 <- matrix(rnorm(n2*sum(d2)),n2,sum(d2))
groups2 <- numeric() ; for(j in 1:q2){ groups2 <- c(groups2,rep(j,d2[j])) }

beta1 <- rnorm(ncol(X1))
beta2 <- rnorm(ncol(X2))
Com <- c(3,4)

Y1 <- rbinom(n1,1,logit(X1 \%*\% beta1))
Y2 <- rbinom(n2,1,logit(X2 \%*\% beta2))

# set tuning parameters
lambda <- 10
eta <- 500
AA1 <- AA2 <- vector("list",min(q1,q2))
for(j in Com){
  n.int <- rpois(1,4)
  AA1[[j]] <- matrix(rnorm(n.int*d1[j]),n.int,d1[j])
  AA2[[j]] <- matrix(rnorm(n.int*d2[j]),n.int,d2[j])
}
w1 <- rexp(q1,2)
w2 <- rexp(q2,2)
w <- rexp(min(q1,q2),2)

n.lambda <- 4
n.eta <- 5
lambda.min.ratio <- .01
n.folds <- 6

grouplasso2pop_logreg_grid_cv.out <- grouplasso2pop_logreg_cv(Y1,X1,groups1,Y2,X2,groups2,n.lambda,n.eta,lambda.min.ratio,n.folds,w1,w2,w,AA1,AA2,Com)

grouplasso2pop_logreg_grid_cv.out$lambda.seq
grouplasso2pop_logreg_grid_cv.out$eta.seq
grouplasso2pop_logreg_grid_cv.out$iterations
}
