% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/semipaddgt2pop_linreg.R
\name{grouplasso2pop_linreg}
\alias{grouplasso2pop_linreg}
\title{Minimize the objective function of the 2-population group lasso problem with a continuous response}
\usage{
grouplasso2pop_linreg(Y1, X1, groups1, Y2, X2, groups2, lambda, eta, w1, w2, w,
  AA1, AA2, Com, tol = 1e-04, max.iter = 500, plot_obj = FALSE,
  init = NULL)
}
\arguments{
\item{Y1}{the response vector of data set 1}

\item{X1}{matrix containing the design matrices for data set 1}

\item{groups1}{a vector of integers indicating to which group each covariate in data set 1 belongs}

\item{Y2}{the response vector of data set 2}

\item{X2}{matrix containing the design matrices for data set 2}

\item{groups2}{a vector of integers indicating to which group each covariate in data set 1 belongs}

\item{lambda}{the level of sparsity penalization}

\item{eta}{the level of penalization towards model similarity}

\item{w1}{group-specific weights for different penalization across groups in data set 1}

\item{w2}{group-specific weights for different penalization across groups in data set 2}

\item{w}{group-specific weights for different penalization toward similarity for different groups}

\item{AA1}{a list of the matrices A1j}

\item{Com}{the indices of the covariate groups which are common in the two datasets}

\item{tol}{a convergence criterion}

\item{max.iter}{the maximum allowed number of iterations}

\item{plot_obj}{a logical indicating whether the value of the objection function should be recorded after every step of the algorithm and these then plotted}

\item{AA1}{a list of the matrices A2j}
}
\value{
Returns the minimizers of the 2-population group lasso objective function for the two data sets.
}
\description{
Minimize the objective function of the 2-population group lasso problem with a continuous response
}
\examples{
# generate data
n1 <- 40
d1 <- c(1,1,3,4)
q1 <- length(d1)
X1 <- scale(matrix(rnorm(n1*sum(d1)),n1,sum(d1)))
groups1 <- numeric() ; for(j in 1:q1){ groups1 <- c(groups1,rep(j,d1[j])) }

n2 <- 200
d2 <- c(1,1,4,3,3,2)
q2 <- length(d2)
X2 <- scale(matrix(rnorm(n2*sum(d2)),n2,sum(d2)))
groups2 <- numeric() ; for(j in 1:q2){ groups2 <- c(groups2,rep(j,d2[j])) }

beta1 <- rnorm(ncol(X1))
beta2 <- rnorm(ncol(X2))
Com <- c(3,4)

e1 <- rnorm(n1)
Y1 <- X1 \%*\% beta1 + e1 - mean(e1)

e2 <- rnorm(n2)
Y2 <- X2 \%*\% beta2 + e2 - mean(e2)

# set tuning parameters
lambda <- 1
eta <- 500
AA1 <- AA2 <- vector("list",min(q1,q2))
for(j in Com){
  n.int <- rpois(1,4)
  AA1[[j]] <- matrix(rnorm(n.int*d1[j]),n.int,d1[j])
  AA2[[j]] <- matrix(rnorm(n.int*d2[j]),n.int,d2[j])
}
w1 <- rexp(q1,2)
w2 <- rexp(q2,2)
w <- rexp(min(q1,q2),2)

# fit grouplasso2pop estimator
grouplasso2pop.out <- grouplasso2pop_linreg(Y1,X1,groups1,Y2,X2,groups2,lambda,eta,w1,w2,w,AA1,AA2,Com,tol=1e-4,max.iter=500,plot_obj=TRUE)
beta1.hat <- grouplasso2pop.out$beta1.hat
beta2.hat <- grouplasso2pop.out$beta2.hat
obj.val <- grouplasso2pop.out$obj.val

# look at results
for(j in Com){
  ind1 <- which(groups1 == j)
  ind2 <- which(groups2 == j)
  print(sum( (AA1[[j]] \%*\% beta1.hat[ind1] - AA2[[j]] \%*\% beta2.hat[ind2] )^2))
}
}
