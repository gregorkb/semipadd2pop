% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/semipaddgt2pop_logreg.R
\name{semipadd2pop_logreg_cv_adapt_fixedgrid}
\alias{semipadd2pop_logreg_cv_adapt_fixedgrid}
\title{Compute semiparametric binary-response regression model with 2 data sets while penalizing dissimilarity using CV to select tuning parameters after an adaptive step}
\usage{
semipadd2pop_logreg_cv_adapt_fixedgrid(Y1, X1, nonparm1, Y2, X2, nonparm2, nCom,
  d1, d2, xi, w1, w2, w, lambda.seq, eta.seq, lambda.initial.fit, n.folds = 5,
  lambda.beta = 1, lambda.f = 1, eta.beta = 1, eta.f = 1, tol = 0.001,
  max.iter = 1000, report.prog = TRUE)
}
\arguments{
\item{Y1}{the binary response vector of data set 1}

\item{X1}{the matrix with the observed covariate values for data set 1 (including a column of ones for the intercept)}

\item{nonparm1}{a vector indicating for which covariates a nonparametric function is to be estimated for data set 1}

\item{Y2}{the binary response vector of data set 2}

\item{X2}{the matrix with the observed covariate values for data set 2 (including a column of ones for the intercept)}

\item{nonparm2}{a vector indicating for which covariates a nonparametric function is to be estimated for data set 2}

\item{nCom}{the number of covariates to be treated as common between the two data sets: these must be arranged in the first \code{nCom} columns of the matrices \code{XX1} and \code{XX2} after the column of ones corresponding to the intercept.}

\item{xi}{a tuning parameter governing the smoothness of the nonparametric estimates}

\item{w1}{covariate-specific weights for different penalization among covariates in data set 1}

\item{w2}{covariate-specific weights for different penalization among covariates in data set 2}

\item{w}{covariate-specific weights for different penalization toward similarity for different covariates}

\item{lambda.seq}{the sequence of lambda values}

\item{eta.seq}{the sequence of eta values}

\item{n.folds}{the number of crossvalidation folds}

\item{lambda.beta}{the level of sparsity penalization for the parametric effects (relative to nonparametric effects)}

\item{lambda.f}{the level of sparsity penalization for the nonparametric effects (relative to the parametric effects)}

\item{eta.beta}{the level of penalization towards model similarity for parametric effects indicated to be common (relative to nonparametric effects)}

\item{eta.f}{the level of penalization towards model similarity for nonparametric effects indicated to be common (relative to the parametric effects)}

\item{tol}{a convergence criterion}

\item{max.iter}{the maximum allowed number of iterations}

\item{d}{the dimension of the B-spline basis to be used when fitting the nonparametric effects}
}
\value{
Returns the estimator of the semiparametric additive model
}
\description{
Compute semiparametric binary-response regression model with 2 data sets while penalizing dissimilarity using CV to select tuning parameters after an adaptive step
}
\examples{
semipadd2pop_logreg_data <- get_semipadd2pop_logreg_data(n1 = 501, n2 = 604)

semipadd2pop_logreg_cv_adapt.out <- semipadd2pop_logreg_cv_adapt( Y1 = semipadd2pop_logreg_data$Y1,
                                                                  X1 = semipadd2pop_logreg_data$X1,
                                                                  nonparm1 = semipadd2pop_logreg_data$nonparm1,
                                                                  Y2 = semipadd2pop_logreg_data$Y2,
                                                                  X2 = semipadd2pop_logreg_data$X2,
                                                                  nonparm2 = semipadd2pop_logreg_data$nonparm2,
                                                                  w1 = 1,
                                                                  w2 = 1,
                                                                  w = 1,
                                                                  nCom = semipadd2pop_logreg_data$nCom,
                                                                  d1 = semipadd2pop_logreg_data$nonparm1*25,
                                                                  d2 = semipadd2pop_logreg_data$nonparm2*15,
                                                                  xi = .5,
                                                                  n.lambda = 5,
                                                                  n.eta = 5,
                                                                  lambda.min.ratio = .01,
                                                                  n.folds = 5,
                                                                  lambda.beta = 1,
                                                                  lambda.f = 1,
                                                                  eta.beta = 1,
                                                                  eta.f = 1,
                                                                  tol = 1e-3,
                                                                  max.iter = 1000,
                                                                  report.prog = FALSE)

semipadd2pop_logreg_cv_adapt_fixedgrid.out <- semipadd2pop_logreg_cv_adapt_fixedgrid(Y1 = semipadd2pop_logreg_data$Y1,
                                                                                     X1 = semipadd2pop_logreg_data$X1,
                                                                                     nonparm1 = semipadd2pop_logreg_data$nonparm1,
                                                                                     Y2 = semipadd2pop_logreg_data$Y2,
                                                                                     X2 = semipadd2pop_logreg_data$X2,
                                                                                     nonparm2 = semipadd2pop_logreg_data$nonparm2,
                                                                                     nCom = semipadd2pop_logreg_data$nCom,
                                                                                     d = 20,
                                                                                     xi = .5,
                                                                                     w1 = 1,
                                                                                     w2 = 1,
                                                                                     w = 1,
                                                                                     lambda.seq = semipadd2pop_logreg_cv_adapt.out$lambda.seq,
                                                                                     eta.seq = semipadd2pop_logreg_cv_adapt.out$eta.seq,
                                                                                     n.folds = 5,
                                                                                     lambda.beta = 1,
                                                                                     lambda.f = 1,
                                                                                     eta.beta = 1,
                                                                                     eta.f = 1,
                                                                                     tol = 1e-2,
                                                                                     max.iter = 500)

plot_semipaddgt2pop_cv(semipadd2pop_logreg_cv_adapt_fixedgrid.out,
                       true.functions = list(f1 = semipadd2pop_logreg_data$f1,
                                             f2 = semipadd2pop_logreg_data$f2,
                                             X1 = semipadd2pop_logreg_data$X1,
                                             X2 = semipadd2pop_logreg_data$X2)
)
}
